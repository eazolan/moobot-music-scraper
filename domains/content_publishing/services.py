"""Content Publishing domain services.

Services for HTML generation, templating, and content publishing.
"""

from datetime import datetime
from pathlib import Path
from typing import List, Dict
from infrastructure.filesystem import FileSystemManager
from infrastructure.logging import UnicodeLogger
from .entities import SongCollection, HtmlPage, PublishingConfig, PublishingResult
from domains.music_queue.entities import SongRequest


class HtmlGenerator:
    """Service for generating HTML content from song collections."""
    
    def __init__(self, config: PublishingConfig):
        self.config = config
    
    def generate_daily_page(self, collection: SongCollection) -> HtmlPage:
        """Generate HTML page for a specific date's song collection."""
        title = f"{self.config.display_streamer_name} Songs - {collection.file_date}"
        content = self._create_daily_html_content(collection)
        file_path = self.config.get_daily_file_path(collection.date)
        
        return HtmlPage(
            content=content,
            title=title,
            file_path=file_path
        )
    
    def generate_index_page(self, collections: List[SongCollection]) -> HtmlPage:
        """Generate index page listing all song collections."""
        title = f"{self.config.display_streamer_name} Songs - Archive"
        content = self._create_index_html_content(collections)
        file_path = self.config.index_file_path
        
        return HtmlPage(
            content=content,
            title=title,
            file_path=file_path
        )
    
    def _create_daily_html_content(self, collection: SongCollection) -> str:
        """Create HTML content for a daily song page."""
        songs_dicts = [song.to_dict() for song in collection.songs]
        
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{collection.streamer_id.display_name} Songs - {collection.file_date}</title>
    <style>
        {self._get_daily_page_css()}
    </style>
</head>
<body>
    <div class="nav">
        <a href="index.html">‚Üê Back to All Dates</a>
    </div>
    
    <div class="header">
        <h1>üéµ {collection.streamer_id.display_name}'s Song Queue</h1>
        <h2>{collection.formatted_date}</h2>
    </div>
    
    <div class="stats">
        <strong>Total Songs Collected:</strong> {collection.song_count}
    </div>
    
    <div class="song-list">
"""
        
        for i, song in enumerate(collection.songs, 1):
            song_dict = song.to_dict()
            html += self._create_song_item_html(i, song_dict)
            
        html += f"""
    </div>
    
    <div class="footer">
        Generated by Moobot Scraper | Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
    </div>
</body>
</html>"""
        
        return html
    
    def _is_ui_text(self, title: str) -> bool:
        """Check if title appears to be UI text rather than a song title."""
        if not title or len(title.strip()) < 3:
            return True
            
        title_lower = title.lower().strip()
        
        # Common UI text patterns
        ui_patterns = [
            "song requests", "moobot", "refresh", "queue", "loading", "error",
            "click here", "search", "menu", "home", "settings", "help",
            "login", "logout", "profile", "dashboard", "navigation",
            "back to", "go to", "view all", "show more", "load more",
            "song queue", "song history", "requested by", "played", "ago",
            "by ", "duration:", "status:"
        ]
        
        # Check for UI patterns
        if any(pattern in title_lower for pattern in ui_patterns):
            return True
        
        # Check for time patterns (like "04:17", "03:41")
        import re
        if re.match(r'^\d{1,2}:\d{2}$', title.strip()):
            return True
        
        # Check for metadata patterns (like "By username X hours ago")
        if re.match(r'^(by|requested by|played)\s+\w+.*\d+\s+(hour|minute|second)s?\s+ago$', title_lower):
            return True
            
        # Check if it's mostly numbers or very short
        if len(title.strip()) < 5 and not re.search(r'[a-zA-Z]', title):
            return True
            
        return False
    
    def _create_index_html_content(self, collections: List[SongCollection]) -> str:
        """Create HTML content for the index page."""
        total_songs = sum(collection.song_count for collection in collections)
        
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.config.display_streamer_name} Songs - Archive</title>
    <style>
        {self._get_index_page_css()}
    </style>
</head>
<body>
    <div class="header">
        <h1>üéµ {self.config.display_streamer_name}'s Song Queue Archive</h1>
        <p>Songs collected from Moobot stream requests</p>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-number">{len(collections)}</div>
            <div class="stat-label">Days Tracked</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{total_songs}</div>
            <div class="stat-label">Total Songs</div>
        </div>
    </div>
    
    <div class="date-list">
"""
        
        # Sort collections by date (newest first)
        sorted_collections = sorted(collections, key=lambda c: c.date, reverse=True)
        
        if not sorted_collections:
            html += """
        <div style="text-align: center; color: #718096; padding: 40px;">
            No songs collected yet. The scraper will start collecting songs once it runs.
        </div>"""
        
        for collection in sorted_collections:
            if collection.song_count > 0:
                html += f"""
        <div class="date-item">
            <a href="songs_{collection.file_date}.html" class="date-link">{collection.formatted_date}</a>
            <span class="song-count">{collection.song_count} songs</span>
        </div>"""
        
        html += f"""
    </div>
    
    <div class="footer">
        Generated by Moobot Scraper | Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
    </div>
</body>
</html>"""
        
        return html
    
    def _create_song_item_html(self, index: int, song_dict: Dict) -> str:
        """Create HTML for a single song item."""
        youtube_link = ""
        youtube_icon = ""
        
        if song_dict.get("youtube_url"):
            url = song_dict["youtube_url"]
            if "youtube.com/results" in url:
                # It's a search URL (fallback)
                youtube_link = f'<a href="{url}" target="_blank" class="youtube-link youtube-search">üîç Search YouTube</a>'
                youtube_icon = " üîç"
            elif "youtube.com/watch" in url or "youtu.be/" in url:
                # Direct YouTube video link
                youtube_link = f'<a href="{url}" target="_blank" class="youtube-link">‚ñ∂Ô∏è Watch on YouTube</a>'
                youtube_icon = " ‚ñ∂Ô∏è"
            else:
                # Other YouTube link (channel, playlist, etc.)
                youtube_link = f'<a href="{url}" target="_blank" class="youtube-link">üéµ Open YouTube</a>'
                youtube_icon = " üéµ"
        else:
            # Generate search URL for songs without direct YouTube links
            title = song_dict.get("title", "")
            # Only generate search URLs for actual song-like titles (not UI text)
            if title and not self._is_ui_text(title):
                import urllib.parse
                search_query = urllib.parse.quote_plus(title)
                search_url = f"https://www.youtube.com/results?search_query={search_query}"
                youtube_link = f'<a href="{search_url}" target="_blank" class="youtube-link youtube-search">üîç Search YouTube</a>'
                youtube_icon = " üîç"
        
        # Use enhanced title if available, otherwise fall back to regular title
        display_title = song_dict.get("enhanced_title", song_dict["title"])
        
        # Build metadata string
        metadata_parts = [f"Collected at {song_dict['scraped_at']}"]
        if song_dict.get("duration"):
            metadata_parts.append(f"Duration: {song_dict['duration']}")
        if song_dict.get("requester"):
            metadata_parts.append(song_dict['requester'])
        if song_dict.get("status"):
            metadata_parts.append(f"Status: {song_dict['status']}")
        
        metadata_string = " | ".join(metadata_parts)
        
        return f"""
        <div class="song-item">
            <div class="song-info">
                <div class="song-title">#{index} {song_dict["title"]}{youtube_icon}</div>
                <div class="song-meta">{metadata_string}</div>
            </div>
            <div class="song-actions">
                {youtube_link}
            </div>
        </div>"""
    
    def _get_daily_page_css(self) -> str:
        """Get CSS styles for daily song pages."""
        return """
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f2f5;
            line-height: 1.6;
        }
        .header {
            background: linear-gradient(135deg, #6441a5, #9146ff);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        .header h2 {
            margin: 0;
            font-weight: 300;
            font-size: 1.3em;
        }
        .song-list {
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .song-item {
            border-bottom: 1px solid #e1e8ed;
            padding: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        .song-item:hover {
            background-color: #f8f9fa;
            margin: 0 -20px;
            padding: 20px 20px;
            border-radius: 8px;
        }
        .song-item:last-child {
            border-bottom: none;
        }
        .song-info {
            flex-grow: 1;
        }
        .song-title {
            font-weight: 600;
            color: #1a202c;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        .song-meta {
            color: #718096;
            font-size: 0.9em;
        }
        .song-time {
            color: #666;
            font-size: 0.9em;
            margin-left: 10px;
        }
        .youtube-link {
            background-color: #ff0000;
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 6px;
            margin-left: 15px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .youtube-link:hover {
            background-color: #cc0000;
            text-decoration: none;
            color: white;
        }
        .youtube-search {
            background-color: #1976d2;
        }
        .youtube-search:hover {
            background-color: #1565c0;
        }
        .song-actions {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }
        .stats {
            margin-bottom: 20px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #e6f3ff, #f0f8ff);
            border-radius: 8px;
            border-left: 4px solid #6441a5;
        }
        .stats strong {
            color: #6441a5;
        }
        .nav {
            text-align: center;
            margin-bottom: 20px;
        }
        .nav a {
            color: #6441a5;
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border: 2px solid #6441a5;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .nav a:hover {
            background-color: #6441a5;
            color: white;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #718096;
            font-size: 0.9em;
            padding: 20px;
        }
        """
    
    def _get_index_page_css(self) -> str:
        """Get CSS styles for the index page."""
        return """
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f2f5;
            line-height: 1.6;
        }
        .header {
            background: linear-gradient(135deg, #6441a5, #9146ff);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #6441a5;
        }
        .stat-label {
            color: #718096;
            margin-top: 5px;
        }
        .date-list {
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .date-item {
            border-bottom: 1px solid #e1e8ed;
            padding: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        .date-item:hover {
            background-color: #f8f9fa;
            margin: 0 -20px;
            padding: 20px;
            border-radius: 8px;
        }
        .date-item:last-child {
            border-bottom: none;
        }
        .date-link {
            color: #6441a5;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1em;
        }
        .date-link:hover {
            text-decoration: underline;
        }
        .song-count {
            background-color: #6441a5;
            color: white;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.9em;
            font-weight: 500;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #718096;
            font-size: 0.9em;
            padding: 20px;
        }
        """


class ContentPublisher:
    """Service for publishing HTML content to files."""
    
    def __init__(self, config: PublishingConfig, logger: UnicodeLogger):
        self.config = config
        self.logger = logger
        self.fs_manager = FileSystemManager(config.output_dir)
    
    def publish_page(self, page: HtmlPage) -> bool:
        """Publish a single HTML page to file.
        
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure the directory exists
            page.file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write the HTML content
            self.fs_manager.write_text_file(page.content, page.file_path)
            
            self.logger.info(f"Published {page.file_name}: {page.content_length} characters")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to publish {page.file_name}: {e}")
            return False
    
    def publish_all(self, collections: List[SongCollection]) -> PublishingResult:
        """Publish all collections to HTML files.
        
        Args:
            collections: List of song collections to publish
            
        Returns:
            Publishing result with success status and generated pages
        """
        result = PublishingResult(success=True)
        
        try:
            # Initialize HTML generator
            generator = HtmlGenerator(self.config)
            
            # Generate and publish daily pages
            for collection in collections:
                if collection.song_count > 0:  # Only publish non-empty collections
                    try:
                        daily_page = generator.generate_daily_page(collection)
                        if self.publish_page(daily_page):
                            result.add_page(daily_page)
                        else:
                            result.add_error(f"Failed to publish page for {collection.file_date}")
                    except Exception as e:
                        error_msg = f"Error generating page for {collection.file_date}: {e}"
                        result.add_error(error_msg)
                        self.logger.error(error_msg)
            
            # Generate and publish index page
            try:
                index_page = generator.generate_index_page(collections)
                if self.publish_page(index_page):
                    result.add_page(index_page)
                else:
                    result.add_error("Failed to publish index page")
            except Exception as e:
                error_msg = f"Error generating index page: {e}"
                result.add_error(error_msg)
                self.logger.error(error_msg)
            
            if result.total_pages > 0:
                self.logger.info(f"Publishing completed: {result.total_pages} pages generated")
            
        except Exception as e:
            error_msg = f"Fatal error during publishing: {e}"
            result.add_error(error_msg)
            self.logger.error(error_msg)
        
        return result